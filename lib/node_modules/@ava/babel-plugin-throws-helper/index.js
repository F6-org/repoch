'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

module.exports = function (babelCore) {
	var t = babelCore.types;
	var wrapArg = babelCore.template('(START(t, ASSERTION, FILE, LINE), END(t, ARG))');
	var helpers = babelCore.template('function START(t, assertion, file, line) {\n  if (t._throwsArgStart) {\n    t._throwsArgStart(assertion, file, line);\n  }\n}\n\nfunction END(t, arg) {\n  if (t._throwsArgEnd) {\n    t._throwsArgEnd();\n  }\n\n  return arg;\n}');

	var assertionVisitor = {
		CallExpression: function CallExpression(path, state) {
			var callee = path.get('callee');
			if (!callee.isMemberExpression() || !callee.get('object').isIdentifier({ name: 't' }) || !callee.get('property').isIdentifier()) {
				return;
			}

			var assertion = callee.get('property').get('name').node;
			if (assertion !== 'throws' && assertion !== 'notThrows') {
				return;
			}

			var arg0 = path.node.arguments[0];
			if (!(arg0 && arg0.loc && typeof arg0.start === 'number' && typeof arg0.end === 'number')) {
				return;
			}

			// Wrap the argument expression, so that the stack trace of the assertion
			// isn't affected.
			path.node.arguments[0] = wrapArg(_extends({
				ARG: arg0,
				ASSERTION: t.stringLiteral(assertion),
				FILE: t.stringLiteral(state.file.opts.filename),
				LINE: t.numericLiteral(arg0.loc.start.line)
			}, this.installHelper())).expression;
		}
	};

	return {
		visitor: {
			Program: function Program(path, state) {
				var START = t.identifier(path.scope.generateUid('avaThrowsHelperStart'));
				var END = t.identifier(path.scope.generateUid('avaThrowsHelperEnd'));
				var helperIdentifiers = { START: START, END: END };

				var created = false;
				path.traverse(assertionVisitor, {
					installHelper: function installHelper() {
						if (!created) {
							created = true;
							path.unshiftContainer('body', helpers(helperIdentifiers));
						}

						return helperIdentifiers;
					},

					file: state.file
				});
			}
		}
	};
};
//# sourceMappingURL=index.js.map