{"version":3,"sources":["../../../src/history/lib/createMemoryHistory.js"],"names":["createStateStorage","entries","filter","entry","state","reduce","memo","key","createMemoryHistory","options","Array","isArray","getCurrentLocation","current","path","readState","init","undefined","canGo","n","index","length","go","currentLocation","history","transitionTo","action","POP","pushLocation","location","splice","push","saveState","replaceLocation","map","storage"],"mappings":"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","file":"createMemoryHistory.js","sourcesContent":["import warning from 'warning'\nimport invariant from 'invariant'\nimport { createLocation } from './LocationUtils'\nimport { createPath, parsePath } from './PathUtils'\nimport createHistory from './createHistory'\nimport { POP } from './Actions'\n\nconst createStateStorage = (entries) =>\n  entries\n    .filter(entry => entry.state)\n    .reduce((memo, entry) => {\n      memo[entry.key] = entry.state\n      return memo\n    }, {})\n\nconst createMemoryHistory = (options = {}) => {\n  if (Array.isArray(options)) {\n    options = { entries: options }\n  } else if (typeof options === 'string') {\n    options = { entries: [ options ] }\n  }\n\n  const getCurrentLocation = () => {\n    const entry = entries[current]\n    const path = createPath(entry)\n\n    let key, state\n    if (entry.key) {\n      key = entry.key\n      state = readState(key)\n    }\n\n    const init = parsePath(path)\n\n    return createLocation({ ...init, state }, undefined, key)\n  }\n\n  const canGo = (n) => {\n    const index = current + n\n    return index >= 0 && index < entries.length\n  }\n\n  const go = (n) => {\n    if (!n)\n      return\n\n    if (!canGo(n)) {\n      warning(\n        false,\n        'Cannot go(%s) there is not enough history',\n        n\n      )\n\n      return\n    }\n\n    current += n\n    const currentLocation = getCurrentLocation()\n\n    // Change action to POP\n    history.transitionTo({ ...currentLocation, action: POP })\n  }\n\n  const pushLocation = (location) => {\n    current += 1\n\n    if (current < entries.length)\n      entries.splice(current)\n\n    entries.push(location)\n\n    saveState(location.key, location.state)\n  }\n\n  const replaceLocation = (location) => {\n    entries[current] = location\n    saveState(location.key, location.state)\n  }\n\n  const history = createHistory({\n    ...options,\n    getCurrentLocation,\n    pushLocation,\n    replaceLocation,\n    go\n  })\n\n  let { entries, current } = options\n\n  if (typeof entries === 'string') {\n    entries = [ entries ]\n  } else if (!Array.isArray(entries)) {\n    entries = [ '/' ]\n  }\n\n  entries = entries.map(entry => createLocation(entry))\n\n  if (current == null) {\n    current = entries.length - 1\n  } else {\n    invariant(\n      current >= 0 && current < entries.length,\n      'Current index must be >= 0 and < %s, was %s',\n      entries.length, current\n    )\n  }\n\n  const storage = createStateStorage(entries)\n\n  const saveState = (key, state) =>\n    storage[key] = state\n\n  const readState = (key) =>\n    storage[key]\n\n  return {\n    ...history,\n    canGo\n  }\n}\n\nexport default createMemoryHistory\n"]}