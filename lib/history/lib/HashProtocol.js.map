{"version":3,"sources":["../../../src/history/lib/HashProtocol.js"],"names":["getUserConfirmation","go","HashChangeEvent","getHashPath","href","window","location","hashIndex","indexOf","substring","pushHashPath","path","hash","replaceHashPath","replace","slice","getCurrentLocation","pathCoder","queryKey","decodePath","key","state","init","undefined","prevLocation","startListener","listener","handleHashChange","encodedPath","encodePath","currentLocation","updateLocation","updateHash","pushLocation","replaceLocation"],"mappings":"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","file":"HashProtocol.js","sourcesContent":["import warning from 'warning'\nimport { createLocation } from './LocationUtils'\nimport { addEventListener, removeEventListener } from './DOMUtils'\nimport { saveState, readState } from './DOMStateStorage'\nimport {\n  addQueryStringValueToPath,\n  stripQueryStringValueFromPath,\n  getQueryStringValueFromPath,\n  parsePath,\n  createPath\n} from './PathUtils'\n\nconst HashChangeEvent = 'hashchange'\n\nconst getHashPath = () => {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  const href = window.location.href\n  const hashIndex = href.indexOf('#')\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1)\n}\n\nconst pushHashPath = (path) =>\n  window.location.hash = path\n\nconst replaceHashPath = (path) => {\n  const hashIndex = window.location.href.indexOf('#')\n\n  window.location.replace(\n    window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path\n  )\n}\n\nexport { getUserConfirmation, go } from './BrowserProtocol'\n\nexport const getCurrentLocation = (pathCoder, queryKey) => {\n  let path = pathCoder.decodePath(getHashPath())\n  const key = getQueryStringValueFromPath(path, queryKey)\n\n  let state\n  if (key) {\n    path = stripQueryStringValueFromPath(path, queryKey)\n    state = readState(key)\n  }\n\n  const init = parsePath(path)\n  init.state = state\n\n  return createLocation(init, undefined, key)\n}\n\nlet prevLocation\n\nexport const startListener = (listener, pathCoder, queryKey) => {\n  const handleHashChange = () => {\n    const path = getHashPath()\n    const encodedPath = pathCoder.encodePath(path)\n\n    if (path !== encodedPath) {\n      // Always be sure we have a properly-encoded hash.\n      replaceHashPath(encodedPath)\n    } else {\n      const currentLocation = getCurrentLocation(pathCoder, queryKey)\n\n      if (prevLocation && currentLocation.key && prevLocation.key === currentLocation.key)\n        return // Ignore extraneous hashchange events\n\n      prevLocation = currentLocation\n\n      listener(currentLocation)\n    }\n  }\n\n  // Ensure the hash is encoded properly.\n  const path = getHashPath()\n  const encodedPath = pathCoder.encodePath(path)\n\n  if (path !== encodedPath)\n    replaceHashPath(encodedPath)\n\n  addEventListener(window, HashChangeEvent, handleHashChange)\n\n  return () =>\n    removeEventListener(window, HashChangeEvent, handleHashChange)\n}\n\nconst updateLocation = (location, pathCoder, queryKey, updateHash) => {\n  const { state, key } = location\n\n  let path = pathCoder.encodePath(createPath(location))\n\n  if (state !== undefined) {\n    path = addQueryStringValueToPath(path, queryKey, key)\n    saveState(key, state)\n  }\n\n  prevLocation = location\n\n  updateHash(path)\n}\n\nexport const pushLocation = (location, pathCoder, queryKey) =>\n  updateLocation(location, pathCoder, queryKey, (path) => {\n    if (getHashPath() !== path) {\n      pushHashPath(path)\n    } else {\n      warning(false, 'You cannot PUSH the same path using hash history')\n    }\n  })\n\nexport const replaceLocation = (location, pathCoder, queryKey) =>\n  updateLocation(location, pathCoder, queryKey, (path) => {\n    if (getHashPath() !== path)\n      replaceHashPath(path)\n  })\n"]}