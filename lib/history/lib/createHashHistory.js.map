{"version":3,"sources":["../../../src/history/lib/createHashHistory.js"],"names":["HashProtocol","DefaultQueryKey","addLeadingSlash","path","charAt","HashPathCoders","hashbang","encodePath","decodePath","substring","noslash","slash","createHashHistory","options","canUseDOM","queryKey","hashType","pathCoder","getUserConfirmation","getCurrentLocation","pushLocation","location","replaceLocation","history","go","listenerCount","stopListener","startListener","listener","before","transitionTo","unlisten","listenBefore","listen","goIsSupportedWithoutReload","n","createHref"],"mappings":"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","file":"createHashHistory.js","sourcesContent":["import warning from 'warning'\nimport invariant from 'invariant'\nimport { canUseDOM } from './ExecutionEnvironment'\nimport { supportsGoWithoutReloadUsingHash } from './DOMUtils'\nimport * as HashProtocol from './HashProtocol'\nimport createHistory from './createHistory'\n\nconst DefaultQueryKey = '_k'\n\nconst addLeadingSlash = (path) =>\n  path.charAt(0) === '/' ? path : '/' + path\n\nconst HashPathCoders = {\n  hashbang: {\n    encodePath: (path) => path.charAt(0) === '!' ? path : '!' + path,\n    decodePath: (path) => path.charAt(0) === '!' ? path.substring(1) : path\n  },\n  noslash: {\n    encodePath: (path) => path.charAt(0) === '/' ? path.substring(1) : path,\n    decodePath: addLeadingSlash\n  },\n  slash: {\n    encodePath: addLeadingSlash,\n    decodePath: addLeadingSlash\n  }\n}\n\nconst createHashHistory = (options = {}) => {\n  invariant(\n    canUseDOM,\n    'Hash history needs a DOM'\n  )\n\n  let { queryKey, hashType } = options\n\n  warning(\n    queryKey !== false,\n    'Using { queryKey: false } no longer works. Instead, just don\\'t ' +\n    'use location state if you don\\'t want a key in your URL query string'\n  )\n\n  if (typeof queryKey !== 'string')\n    queryKey = DefaultQueryKey\n\n  if (hashType == null)\n    hashType = 'slash'\n\n  if (!(hashType in HashPathCoders)) {\n    warning(\n      false,\n      'Invalid hash type: %s',\n      hashType\n    )\n\n    hashType = 'slash'\n  }\n\n  const pathCoder = HashPathCoders[hashType]\n\n  const { getUserConfirmation } = HashProtocol\n\n  const getCurrentLocation = () =>\n    HashProtocol.getCurrentLocation(pathCoder, queryKey)\n\n  const pushLocation = (location) =>\n    HashProtocol.pushLocation(location, pathCoder, queryKey)\n\n  const replaceLocation = (location) =>\n    HashProtocol.replaceLocation(location, pathCoder, queryKey)\n\n  const history = createHistory({\n    getUserConfirmation, // User may override in options\n    ...options,\n    getCurrentLocation,\n    pushLocation,\n    replaceLocation,\n    go: HashProtocol.go\n  })\n\n  let listenerCount = 0, stopListener\n\n  const startListener = (listener, before) => {\n    if (++listenerCount === 1)\n      stopListener = HashProtocol.startListener(\n        history.transitionTo,\n        pathCoder,\n        queryKey\n      )\n\n    const unlisten = before\n      ? history.listenBefore(listener)\n      : history.listen(listener)\n\n    return () => {\n      unlisten()\n\n      if (--listenerCount === 0)\n        stopListener()\n    }\n  }\n\n  const listenBefore = (listener) =>\n    startListener(listener, true)\n\n  const listen = (listener) =>\n    startListener(listener, false)\n\n  const goIsSupportedWithoutReload = supportsGoWithoutReloadUsingHash()\n\n  const go = (n) => {\n    warning(\n      goIsSupportedWithoutReload,\n      'Hash history go(n) causes a full page reload in this browser'\n    )\n\n    history.go(n)\n  }\n\n  const createHref = (path) =>\n    '#' + pathCoder.encodePath(history.createHref(path))\n\n  return {\n    ...history,\n    listenBefore,\n    listen,\n    go,\n    createHref\n  }\n}\n\nexport default createHashHistory\n"]}