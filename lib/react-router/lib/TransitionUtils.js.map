{"version":3,"sources":["../../../src/react-router/lib/TransitionUtils.js"],"names":["getTransitionUtils","PendingHooks","hooks","add","push","hook","remove","filter","h","has","indexOf","clear","enterHooks","changeHooks","createTransitionHook","route","asyncArity","pendingHooks","isSync","length","transitionHook","args","apply","callback","getEnterHooks","routes","reduce","onEnter","getChangeHooks","onChange","runTransitionHooks","iter","redirectInfo","replace","location","index","next","done","error","runEnterHooks","nextState","wrappedNext","runChangeHooks","state","runLeaveHooks","prevState","i","len","onLeave","call"],"mappings":"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","file":"TransitionUtils.js","sourcesContent":["import { loopAsync } from './AsyncUtils'\n\nclass PendingHooks {\n  hooks = []\n  add = hook => this.hooks.push(hook)\n  remove = hook => this.hooks = this.hooks.filter(h => h !== hook)\n  has = hook => this.hooks.indexOf(hook) !== -1\n  clear = () => this.hooks = []\n}\n\nexport default function getTransitionUtils() {\n  const enterHooks = new PendingHooks()\n  const changeHooks = new PendingHooks()\n\n  function createTransitionHook(hook, route, asyncArity, pendingHooks) {\n    const isSync = hook.length < asyncArity\n\n    const transitionHook = (...args) => {\n      hook.apply(route, args)\n\n      if (isSync) {\n        let callback = args[args.length - 1]\n        // Assume hook executes synchronously and\n        // automatically call the callback.\n        callback()\n      }\n    }\n\n    pendingHooks.add(transitionHook)\n\n    return transitionHook\n  }\n\n  function getEnterHooks(routes) {\n    return routes.reduce(function (hooks, route) {\n      if (route.onEnter)\n        hooks.push(createTransitionHook(route.onEnter, route, 3, enterHooks))\n      return hooks\n    }, [])\n  }\n\n  function getChangeHooks(routes) {\n    return routes.reduce(function (hooks, route) {\n      if (route.onChange)\n        hooks.push(createTransitionHook(route.onChange, route, 4, changeHooks))\n      return hooks\n    }, [])\n  }\n\n  function runTransitionHooks(length, iter, callback) {\n    if (!length) {\n      callback()\n      return\n    }\n\n    let redirectInfo\n    function replace(location) {\n      redirectInfo = location\n    }\n\n    loopAsync(length, function (index, next, done) {\n      iter(index, replace, function (error) {\n        if (error || redirectInfo) {\n          done(error, redirectInfo) // No need to continue.\n        } else {\n          next()\n        }\n      })\n    }, callback)\n  }\n\n  /**\n   * Runs all onEnter hooks in the given array of routes in order\n   * with onEnter(nextState, replace, callback) and calls\n   * callback(error, redirectInfo) when finished. The first hook\n   * to use replace short-circuits the loop.\n   *\n   * If a hook needs to run asynchronously, it may use the callback\n   * function. However, doing so will cause the transition to pause,\n   * which could lead to a non-responsive UI if the hook is slow.\n   */\n  function runEnterHooks(routes, nextState, callback) {\n    enterHooks.clear()\n    const hooks = getEnterHooks(routes)\n    return runTransitionHooks(hooks.length, (index, replace, next) => {\n      const wrappedNext = (...args) => {\n        if (enterHooks.has(hooks[index])) {\n          next(...args)\n          enterHooks.remove(hooks[index])\n        }\n      }\n      hooks[index](nextState, replace, wrappedNext)\n    }, callback)\n  }\n\n  /**\n   * Runs all onChange hooks in the given array of routes in order\n   * with onChange(prevState, nextState, replace, callback) and calls\n   * callback(error, redirectInfo) when finished. The first hook\n   * to use replace short-circuits the loop.\n   *\n   * If a hook needs to run asynchronously, it may use the callback\n   * function. However, doing so will cause the transition to pause,\n   * which could lead to a non-responsive UI if the hook is slow.\n   */\n  function runChangeHooks(routes, state, nextState, callback) {\n    changeHooks.clear()\n    const hooks = getChangeHooks(routes)\n    return runTransitionHooks(hooks.length, (index, replace, next) => {\n      const wrappedNext = (...args) => {\n        if (changeHooks.has(hooks[index])) {\n          next(...args)\n          changeHooks.remove(hooks[index])\n        }\n      }\n      hooks[index](state, nextState, replace, wrappedNext)\n    }, callback)\n  }\n\n  /**\n   * Runs all onLeave hooks in the given array of routes in order.\n   */\n  function runLeaveHooks(routes, prevState) {\n    for (let i = 0, len = routes.length; i < len; ++i)\n      if (routes[i].onLeave)\n        routes[i].onLeave.call(routes[i], prevState)\n  }\n\n  return {\n    runEnterHooks,\n    runChangeHooks,\n    runLeaveHooks\n  }\n}\n"]}