{"version":3,"sources":["../../../src/dom-helper/ric/index.js"],"names":["rIC","callback","number","process","env","BROWSER","frameCallback","setTimeout","timeRemaining","Infinity","requestIdleCallback","scheduledRICCallback","isIdleScheduled","isAnimationFrameScheduled","frameDeadline","previousFrameTime","activeFrameTime","frameDeadlineObject","Date","now","messageKey","Math","random","toString","slice","idleTick","event","source","window","data","addEventListener","animationTick","rafTime","nextFrameTime","postMessage"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA;;AAEA;AACA,IAAIA,MAAM,aAACC,QAAD;AAAA,WAAcC,MAAd;AAAA,CAAV;;AAEA,IAAI,CAACC,QAAQC,GAAR,CAAYC,OAAjB,EAA0B;AACtBL,UAAM,aAASM,aAAT,EAAwB;AAC1BC,mBAAW,YAAM;AACbD,0BAAc;AACVE,6BADU,2BACM;AACZ,2BAAOC,QAAP;AACH;AAHS,aAAd;AAKH,SAND;AAOA,eAAO,CAAP;AACH,KATD;AAUH,CAXD,MAWO,IAAI,OAAOC,mBAAP,KAA+B,UAAnC,EAA+C;AAClD;AACA,QAAIC,uBAAuB,IAA3B;;AAEA,QAAIC,kBAAkB,KAAtB;AACA,QAAIC,4BAA4B,KAAhC;;AAEA,QAAIC,gBAAgB,CAApB;AACA;AACA;AACA;AACA,QAAIC,oBAAoB,EAAxB;AACA,QAAIC,kBAAkB,EAAtB;;AAEA,QAAIC,sBAAsB;AACtBT,uBAAe,yBAAW;AACtB;AACA,mBAAOM,gBAAgBI,KAAKC,GAAL,EAAvB;AACH;AAJqB,KAA1B;;AAOA;AACA,QAAIC,aAAa,0BAA0BC,KAAKC,MAAL,GAAcC,QAAd,CAAuB,EAAvB,EAA2BC,KAA3B,CAAiC,CAAjC,CAA3C;AACA,QAAIC,WAAW,SAAXA,QAAW,CAASC,KAAT,EAAgB;AAC3B,YAAIA,MAAMC,MAAN,KAAiBC,MAAjB,IAA2BF,MAAMG,IAAN,KAAeT,UAA9C,EAA0D;AACtD;AACH;AACDR,0BAAkB,KAAlB;AACA,YAAIX,WAAWU,oBAAf;AACAA,+BAAuB,IAAvB;AACA,YAAIV,aAAa,IAAjB,EAAuB;AACnBA,qBAASgB,mBAAT;AACH;AACJ,KAVD;AAWA;AACA;AACAW,WAAOE,gBAAP,CAAwB,SAAxB,EAAmCL,QAAnC,EAA6C,KAA7C;;AAEA,QAAIM,gBAAgB,SAAhBA,aAAgB,GAAW;AAC3B,YAAIC,UAAUd,KAAKC,GAAL,EAAd;AACAN,oCAA4B,KAA5B;AACA,YAAIoB,gBAAgBD,UAAUlB,aAAV,GAA0BE,eAA9C;AACA,YACIiB,gBAAgBjB,eAAhB,IACAD,oBAAoBC,eAFxB,EAGE;AACE,gBAAIiB,gBAAgB,CAApB,EAAuB;AACnB;AACA;AACAA,gCAAgB,CAAhB;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACAjB,8BAAkBiB,gBAAgBlB,iBAAhB,GACZA,iBADY,GAEZkB,aAFN;AAGH,SAnBD,MAmBO;AACHlB,gCAAoBkB,aAApB;AACH;AACDnB,wBAAgBkB,UAAUhB,eAA1B;AACA,YAAI,CAACJ,eAAL,EAAsB;AAClBA,8BAAkB,IAAlB;AACAgB,mBAAOM,WAAP,CAAmBd,UAAnB,EAA+B,GAA/B;AACH;AACJ,KA/BD;;AAiCApB,UAAM,aAASC,QAAT,EAAmB;AACrB;AACAU,+BAAuBV,QAAvB;AACA,YAAI,CAACY,yBAAL,EAAgC;AAC5B;AACA;AACA;AACA;AACAA,wCAA4B,IAA5B;AACA,4BAAIkB,aAAJ;AACH;AACD,eAAO,CAAP;AACH,KAZD;AAaH,CApFM,MAoFA;AACH/B,UAAMU,mBAAN;AACH;;kBAEcV,G","file":"index.js","sourcesContent":["'use strict';\n\n// This is a built-in polyfill for requestIdleCallback. It works by scheduling\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\nimport { RAF } from '../raf/index';\n\n// TODO: There's no way to cancel\nlet rIC = (callback) => number;\n\nif (!process.env.BROWSER) {\n    rIC = function(frameCallback) {\n        setTimeout(() => {\n            frameCallback({\n                timeRemaining() {\n                    return Infinity;\n                },\n            });\n        });\n        return 0;\n    };\n} else if (typeof requestIdleCallback !== 'function') {\n    // Polyfill requestIdleCallback.\n    var scheduledRICCallback = null;\n\n    var isIdleScheduled = false;\n    var isAnimationFrameScheduled = false;\n\n    var frameDeadline = 0;\n    // We start out assuming that we run at 30fps but then the heuristic tracking\n    // will adjust this value to a faster fps if we get more frequent animation\n    // frames.\n    var previousFrameTime = 16;\n    var activeFrameTime = 16;\n\n    var frameDeadlineObject = {\n        timeRemaining: function() {\n            // As a fallback we use Date.now.\n            return frameDeadline - Date.now();\n        }\n    };\n\n    // We use the postMessage trick to defer idle work until after the repaint.\n    var messageKey = '__repochIdleCallback$' + Math.random().toString(36).slice(2);\n    var idleTick = function(event) {\n        if (event.source !== window || event.data !== messageKey) {\n            return;\n        }\n        isIdleScheduled = false;\n        var callback = scheduledRICCallback;\n        scheduledRICCallback = null;\n        if (callback !== null) {\n            callback(frameDeadlineObject);\n        }\n    };\n    // Assumes that we have addEventListener in this environment. Might need\n    // something better for old IE.\n    window.addEventListener('message', idleTick, false);\n\n    var animationTick = function() {\n        var rafTime = Date.now();\n        isAnimationFrameScheduled = false;\n        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n        if (\n            nextFrameTime < activeFrameTime &&\n            previousFrameTime < activeFrameTime\n        ) {\n            if (nextFrameTime < 8) {\n                // Defensive coding. We don't support higher frame rates than 120hz.\n                // If we get lower than that, it is probably a bug.\n                nextFrameTime = 8;\n            }\n            // If one frame goes long, then the next one can be short to catch up.\n            // If two frames are short in a row, then that's an indication that we\n            // actually have a higher frame rate than what we're currently optimizing.\n            // We adjust our heuristic dynamically accordingly. For example, if we're\n            // running on 120hz display or 90hz VR display.\n            // Take the max of the two in case one of them was an anomaly due to\n            // missed frame deadlines.\n            activeFrameTime = nextFrameTime < previousFrameTime\n                ? previousFrameTime\n                : nextFrameTime;\n        } else {\n            previousFrameTime = nextFrameTime;\n        }\n        frameDeadline = rafTime + activeFrameTime;\n        if (!isIdleScheduled) {\n            isIdleScheduled = true;\n            window.postMessage(messageKey, '*');\n        }\n    };\n\n    rIC = function(callback) {\n        // This assumes that we only schedule one callback at a time\n        scheduledRICCallback = callback;\n        if (!isAnimationFrameScheduled) {\n            // If rAF didn't already schedule one, we need to schedule a frame.\n            // TODO: If this rAF doesn't materialize because the browser throttles, we\n            // might want to still have setTimeout trigger rIC as a backup to ensure\n            // that we keep performing work.\n            isAnimationFrameScheduled = true;\n            RAF(animationTick);\n        }\n        return 0;\n    };\n} else {\n    rIC = requestIdleCallback;\n}\n\nexport default rIC;\n\n"]}